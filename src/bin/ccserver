#!/usr/bin/env python
#
# ccloud bottle server.
#

import os
import sys
import getopt
import re
import bottle
from bottle import route, run, request, abort
import StringIO
import json
import numpy as np
import Image
from datetime import datetime
import shapely.geometry

import ccloud
import ccloud.utils
from ccloud.config import sharepath


# Index.
@route('/')
@route('/about/')
def index():
    return bottle.static_file('index.html', root=os.path.join(sharepath, 'www'))


# Profile.
@route('<filename:re:/profile\.json>')
def profile(filename):
    return bottle.static_file(filename, root=config['root'])


# Colormaps
@route('/colormaps/<name>')
def colormap(name):
    if os.path.exists(os.path.join(config['colormaps'], name)):
        return bottle.static_file(name, root=config['colormaps'])
    return bottle.static_file(name, root=os.path.join(sharepath, 'www', 'colormaps'))


# Places.
@route('/layers/places/<zoom>/<x>.json')
def places(zoom, x):
    try:
        trajectory = profile.load('trajectory', zoom, x, 0)
        geography = profile.load('geography')
    except IOError: return json.dumps({'places': []})
    
    points = np.array(trajectory['features'][0]['geometry']['coordinates'])
    
    # Downsample.
    if request.query.reduce:
        try: factor = int(request.query.reduce)
        except ValueError: factor = 1
        if factor <= 0: factor = 1
        points = points[np.arange(0, points.shape[0]) % factor == 0,:]
    
    t = shapely.geometry.shape({
        'type': 'LineString',
        'coordinates': points,
    })
    
    out = np.zeros(points.shape[0], np.int)
    
    for i in range(len(geography['features'])):
        s = shapely.geometry.shape(geography['features'][i]['geometry'])
        intersection = s.intersection(t)
        if type(intersection) != shapely.geometry.LineString: continue
        for point in intersection.coords:
            for j in range(len(points)):
                if points[j][0] == point[0] and points[j][1] == point[1]:
                    out[j] = i
    
    return json.dumps({'places': list(out)}, indent=True)


# Geocoding.
@route('/layers/geocoding/<zoom>/<x>.json')
def geocoding(zoom, x):
    try:
        trajectory = profile.load('trajectory', zoom, x, 0)
        geography = profile.load('geography')
    except IOError:
        abort(404)
    
    geom = {}
    geom['type'] = trajectory['features'][0]['geometry']['type']
    geom['coordinates'] = trajectory['features'][0]['geometry']['coordinates']
    
    # Downsample.
    if request.query.reduce:
        try: factor = int(request.query.reduce)
        except ValueError: factor = 1
        if factor <= 0: factor = 1
        n = len(geom['coordinates'])
        coords = np.array(geom['coordinates'])
        coords = coords[np.arange(0, n) % factor == 0,:]
        geom['coordinates'] = coords
    
    t = shapely.geometry.shape(geom)
    
    features = []
    
    for f in geography['features']:
        s = shapely.geometry.shape(f['geometry'])
        i = s.intersection(t)
        if type(i) != shapely.geometry.linestring.LineString:
            continue
        
        features.append({
            'type': 'Feature',
            'properties': f['properties'],
            'geometry': {
                'type': 'LineString',
                'coordinates': list(i.coords),
            },
        })

    return json.dumps({
        'type': 'FeatureCollection',
        'features': features,
    }, indent=True)


# Availability.
#@route('/layers/calipso532/availability.json')
#def availability():
#    return json.dumps({
#        '2': [
#            (2243747, 2243927),
#        ],
#    })


# Layers.
@route('/layers/<src:path>')
def serve(src):   
    if src.endswith('.json'):
        return serve_geojson(src)
    else:
        return serve_tile(src)


# Everything else.
@route('<filename:path>')
def default(filename):
    return bottle.static_file(filename, root=os.path.join(sharepath, 'www'))


def cache(src):
    with open(src) as fp:
        geojson = json.load(fp)
    

def serve_geojson(src):    
    if not request.query.q:
        return bottle.static_file(src, root=config['layers'])

    q = request.query.q
    m = re.match('^(-?\d+(?:\.\d+)?),(-?\d+(?:\.\d+)?)$', q)
    if not m: abort(404)
    try:
        lat = float(m.group(1))
        lon = float(m.group(2))
    except ValueError:
        abort(404)
    
    point = shapely.geometry.Point(lon, lat)

    if not serve_geojson.cache.has_key(src):
        with open(os.path.join(config['layers'], src)) as fp:
            serve_geojson.cache[src] = json.load(fp)
        
    geojson = serve_geojson.cache[src]
        
    for f in geojson['features']:
        s = shapely.geometry.shape(f['geometry'])
        if s.contains(point):
            return json.dumps(f['properties'])
    
    return json.dumps({})

serve_geojson.cache = {}


def serve_tile(src):
    cfilename = os.path.join(config['cache'], src)
    ifilename = os.path.join(config['layers'], src)
    
    # Cache.
    if not request.query.q:
        try:
            istat = os.stat(ifilename)
            cstat = os.stat(cfilename)
            
            # Cache is up to date.
            if cstat.st_mtime >= istat.st_mtime:
                return bottle.static_file(src, root=config['cache'])
        except OSError: pass
    
    try: data = ccloud.utils.pngunpack(ifilename)
    except IOError: abort(404)
    
    if request.query.q:
        q = request.query.q
        m = re.match('^(\d+),(\d+)$', q)
        if m:
            x, y = int(m.group(1)), int(m.group(2))
            try: return unicode(data[y, x])
            except ValueError: pass
        abort(404)
    
    try:
        with open(os.path.join(config['root'], 'colormaps', profile['layers']['calipso532']['colormap'])) as fp:
            colormap = json.load(fp)
    except IOError:
        with open(os.path.join(sharepath, profile['layers']['calipso532']['colormap'])) as fp:
            colormap = json.load(fp)
    
    out = Image.fromarray(ccloud.utils.colorize(data, colormap))
    
    # Save to cache.
    try: os.makedirs(os.path.dirname(cfilename))
    except OSError: pass
    out.save(cfilename)
    
    response = StringIO.StringIO()
    out.save(response, format='PNG')
    bottle.response.content_type = 'image/png'
    
    return response.getvalue()


def usage():
    sys.stderr.write('''Usage: {program_name} [-d] [-h HOST] [-p PORT] [ROOT]
       {program_name} --help
Try `{program_name} --help' for more information.
'''.format(program_name=program_name))


def print_help():
    sys.stderr.write('''Usage: {program_name} [-d] [-h HOST] [-p PORT] [ROOT]
       {program_name} --help
       
Run the ccloud HTTP server.

Positional arguments:
  ROOT              document root (default: .)

Optional arguments:

  -d                print debugging information
  -h HOST           hostname (default: localhost)
  -p PORT           port (default: 8080)
  --help            print this help information

Report bugs to <ccplot-general@lists.sourceforge.net>.
'''.format(program_name=program_name))


if __name__ == "__main__":
    # Default configuration.
    config = {
        'host': 'localhost',
        'port': 8080,
        'debug': False,
        'root': '.',
    }
    
    # Command line arguments.
    program_name = sys.argv[0]
    try: opts, args = getopt.getopt(sys.argv[1:], "dh:p:", ['help'])
    except getopt.GetoptError, err:
        print unicode(err)
        usage()
        sys.exit(1)
    
    for opt,value in opts:
        if opt == '-d':
            config['debug'] = True
        elif opt == '-h':
            config['host'] = value
        elif opt == '-p':
            config['port'] = value
        elif opt == '--help':
            print_help()
            sys.exit(0)

    if len(args) > 1:
        usage()
        sys.exit(1)
    
    if len(args) >= 1: config['root'] = args[0]
    config['cache'] = os.path.join(config['root'], 'cache')
    config['colormaps'] = os.path.join(config['root'], 'colormaps')
    config['layers'] = os.path.join(config['root'], 'layers')
    
    profile = ccloud.Profile(os.path.join(config['root'], 'profile.json'))
    
    bottle.debug(config['debug'])
    run(host=config['host'], port=config['port'], reloader=True)
